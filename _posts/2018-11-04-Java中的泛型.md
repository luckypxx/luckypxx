### JDK1.5新特性

- 方法的可变参数

**语法：**

数据类型 ... 可变参数名称

```java
int ... data
```

> a. 可变参数的本质是数组
>
> b. 一个方法中只允许一个可变参数，可变参数一定是方法最后一个参数

- foreach循环

只用于数组、类集内容的取得，不能修改原数组、类集内容

```java
for (数据类型 临时变量 : 数组名/类集名)
例：
for(int temp:data)
```

- 静态导入

将一个类的所有静态域（包含静态属性、方法），全部导入到使用类中，此时调用属性和方法不再需要类名

### 泛型

#### 泛型类

所谓的泛型指的是在定义类时，并不会设置类中的属性或方法的参数的具体类型，而是在类使用时再定义

安全性考虑，不再有类型转换异常

- 语法

```java
class MyClass<T>{
    T t;
}
```

<>中的T被称为类型参数，用于指代任何类型

- 出于规范起见，类型参数一般由单个的大写字母来表示：

T：代表用在泛型类声明上，指代泛型类

E:一般用于属性

K、V：键值对

当泛型类中需要多个不同类型变量时，<>以，分隔声明不同大写字母即可

```java
class MyClass<T,E>{
    T t;
    E x;
}
```

**泛型的出现彻底解决了向下转型带来的ClassCastException问题**

**泛型只能用引用数据类型，基本类型使用包装类**

#### 泛型方法

- 语法

```java
public <T> void method(T t){
    
}
```

当泛型类与泛型方法共存时，泛型方法中的类型参数与泛型类的类型参数无关，泛型方法始终以自己的类型参数为准

规范起见，当泛型类与泛型方法共存时，请使用不同的类型参数来区分彼此

### 通配符

解决泛型参数统一化问题

- ？通配符

作用于方法参数声明

```java
public static void print(MyClass<?> myClass){
    
}
```

此时方法参数表示可以接收任意类型的MyClass对象

由于无法确定入参的类型，因此？通配符下的泛型参数，只能取得类中属性值，无法进行属性值的设置

- 设置泛型上限

用于泛型类声明：`T extends 类`，即T是这个类本身或其子类

方法参数：`？ extends 类`

eg: `? extends Number : `

表示方法入参只能接收Number以及其子类对象

方法参数设置泛型上限仍然取得类中属性值，而无法设置，因为设置父类值子类不一定能使用（父类不一定能发生向下转型变为子类）

- 设置泛型下限---只能用于方法参数

`? super 类()`,这个类或这个类的父类

表示方法入参只能接收类以及其父类对象

方法参数设置泛型下限不仅可以取得类中属性值，还可以设置属性值。因为子类可以天然向上转型变为父类

#### 泛型接口

- 子类实现接口时继续保留泛型

```java
public InterfaceImpl<T> implements IInterface<T>{}
```

- 子类实现接口时就确定好类型

```java
public InterfaceImpl implements IImterface<String>{}
```

#### 类型擦除

**泛型信息仅存在代码编译阶段**，进入JVM之前，与泛型相关的信息会被擦除掉，专业术语就叫做类型擦除

换句话说，泛型类与普通类在JVM中没有任何差别

泛型类进入JVM之前会进行类型擦除，泛型类的类型参数如果没有指定类型上限，则擦除成为Object类；如果类型参数指定类型上限，擦除为相应类型上限

\<T>---> Object

\<T extends String> -> String

