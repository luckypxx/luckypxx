# Lock体系

特点：需要手动的加锁和解锁

JDK1.5之后增加java.util.concurrent.locks提供了与内键锁完全不同的实现多线程共享资源访问机制。失去了内键锁隐式的加锁与解锁过程，增加了可中断的获取锁以及超时获取锁以及共享锁等内键锁不具备的特性。

### lock锁的标准使用形式

```java
Lock lock = new ReentrantLock()
try{
    lock.lock();
    //同步块
}finally{
    lock.unlock();
}
```

### Lock接口API

1.`void lock();`//获取锁

2.`void lockInterruptibly() throws InterruptedException;`//获取锁的过程能够响应中断（lock独有）

3.`boolean tryLock();`//获取锁返回true，反之返回false，可以响应中断

4.`boolean tryLock(long time,TimeUnit unit);`//在3的基础上增加了超时等待机制，规定时间内未获取到锁，线程直接返回（lock独有）

5.`void unlock()`//解锁

### Lock体系核心存在---AbstractQueuedSynchronizer(AQS同步器)

- 同步器的作用

同步器是用来构建锁与其他同步组件的基础框架。它的组成有两部分：FIFO队列（同步队列）、int成员变量（同步状态）

要使用AQS，推荐使用静态内部类继承AQS，覆写AQS中的protected用来改变同步状态的方法，其他方法主要是实现排队与堵塞机制。状态更新使用`getState()`、`setState()`、`compareAndSetState()`

Lock面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节：

AQS面向锁的实现者，简化了锁的实现方式，屏蔽同步状态的管理、线程排队、线程等待与唤醒等底层操作

### AQS提供的模板方法

AQS分为两类：独占锁和共享锁

- 独占锁

1、`void acquire(int arg)`

独占式获取同步状态，如果获取失败则将当前线程插入同步队列进行等待

2、`void acquireTnterruptibly(int arg)`

在1的基础上增加响应中断

3、`boolean tryAcquireNanos(int arg,long nanosTimeOut)`

在2的基础上增加超时等待，在规定时间内未获取到同步状态返回false

4、`boolean tryAcquire(int arg)`

获取状态成功返回true，否则返回false

5、`boolean release(int arg)`

释放同步状态，该方法或唤醒在同步队列中的下一个节点

- 共享锁

AQS中的同步队列是一个带有头尾节点的双向链表，节点的组成为

`Node prev`

`Node next`

`Thread thread`

将线程封装为Node节点后进行入队与出队处理

### 深入理解AQS

- 独占式锁的获取---acquire

1.`tryAcquire()`:再次使用CAS尝试获取同步状态，若成功方法直接返回，当前线程置为持有锁线程；若再次尝试失败，调用`addWaiter()`

2.`addWaiter()`:将当前线程封装从节点尾插到同步队列中，成功则调用`acquireQueued(Node node,int arg)`；失败则调用`enq()`方法

3.`enq()`:当同步队列为空时，完成队列的初始化操作，以及不断尝试用CAS方法将当前线程封装的结点尾插到同步队列中

4.

### 独占式锁的释放-release()

 