# 反射

反射指的是对象的反向处理，根据对象倒推类的组成

### 反射的核心类---class类

反射的核心类是专门描述其他类的组成

Object类中取得对象的class对象，class对象是用来描述接口与类的组成的，由JVM在第一次加载类时产生，并且全局唯一。

#### 取得任意类Class对象方法

- `调用对象.getClass()`取得Class对象
- `类名称.class`取得Class对象
- `Class.forName(类全称->包名.类名)`取得类对象

```java
//通过反射实例化类对象
public T newInstance();
```

### 类加载器

- 类加载的定义

通过一个类的全名称来获取此类的二进制字节流

- 类加载器

实现类加载功能的代码模块

### JDK内置的三大类加载器

- 启动类加载器---BootStrap

1.使用C++语言实现，是JVM自身的一部分，独立于JVM外部，并且无法被Java程序直接引用

2.负责将存放于JAVA_HOME\lib目录下的能被JVM识别的所有类库加载到JVM中

例如：rt.jar是Java的基础类库

- 扩展类加载器---ExtClassLoader

1.使用Java语言实现，可以被Java程序直接引用

2.负责将存放于JAVA_HOME\lib\ext(xml文件解析类、界面框架类)目录下的所有能被JVM识别的类库

- 应用程序类加载器---AppClassLoader

1.使用Java程序实现，如果用户没有自定义类加载器，则APPClassLoader就是程序中默认的类加载器

2.负责加载用户classPath指定的类库

### 类加载器的双亲委派模型

- 定义

四种类加载器的层次关系称为类加载器双亲委派模型

- 工作流程

如果一个类加载器收到了类加载的请求，首先不会自己尝试自己加载此类，而是将类加载器请求委托给父类加载器完成，每一层的类加载器都是如此。只有当父加载器无法加载此类时，子加载器才会尝试自己去加载。

- 存在意义

双亲委派模型对于保证Java程序的稳定运行十分重要。

例如：Java.lang.Object，它存放在rt.jar中，由于双亲委派模型的存在，无论哪一类类加载器要加载此类，最终都是委派给处于顶端的启动类加载器进行加载的。因此，Object类在程序的各种类加载器环境中都是同一个类。

**比较两个类是否相同的前提条件：**这两个类是由同一个类加载器加载的。

否则即使两个类来源同一个Class文件，被同一个JVM加载，只有加载这两个类的类加载器不是同一个，这两个类就不说同一个类

### 动态代理

代理类不再实现某一具体接口，而要实现InvocationHandler接口