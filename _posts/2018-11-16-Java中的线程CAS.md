---
layout: post
title:乐观锁CAS操作---compare and Swap
date: 2018-11-12

tag: Java
--- 

### 悲观锁概念---JDK1.6之前

假设每一次执行同步代码块均会产生冲突，所以当线程获取锁成功，会阻塞其他尝试该锁的线程

### 乐观锁概念

假设所有线程访问共享资源时不会出现冲突，既然不会出现冲突自然就不会阻塞其他线程。线程就不会出现阻塞状态

CAS是无锁操作，使用CAS叫做比较交换来判断是否出现冲突，出现冲突就重试直到不冲突为止

### CAS的操作过程

CAS的交换过程有三个值：V（内存中地址存放的实际值）、O（内存中地址存放的预期值）、N（内存中地址存放的更新后的值）

- 当执行CAS后

如果V==O，即旧值与内存中的实际值相等，表示上次修改该值后没有任何线程再次修改此值，因此可以将N替换到内存中；

如果V！=O，表示该内存中的值已经被其他线程做了修改，所以无法将N替换，返回最新的值V

当多个线程使用CAS操作同一个变量时，只有一个线程会成功，并成功更新变量值，其余线程均会失败。失败线程会重新尝试或将线程挂起（阻塞）

synchronized最主要的问题：当存在线程竞争的情况下，会出现线程阻塞以及唤醒带来的性能问题，对应互斥同步（阻塞同步），效率很低

而CAS并不是武断的将线程挂起，会尝试若干次CAS操作，并非进行耗时的挂起与唤醒操作，因此非阻塞式同步

### CAS产生的问题

- ABA问题

ABA问题指的是，当线程1 拿到这把锁后将N值改为线程1的值，当线程1执行完该代码块的内容后，去执行了另一段同步代码块的内容。这时线程2要来执行这段代码块，这是V的值与O的值相等，那么线程2也就拿到了这把锁，在他执行完这段代码后，此时N的值和之前的值相同。而当线程1再次来哪这把锁时，仍然满足V == O，如何解决？

解决思路：沿用数据库的乐观锁机制，添加版本号1A-2B-3A

JDK1.5提供atomic包下AtomicStampedReference类来解决CAS的ABA问题

- 自旋会浪费大量的处理器资源

自旋即当进程遇到V！=O时，进程会不断地尝试。与线程阻塞相比，自旋会浪费大量的CPU资源，因为此时线程仍处于运行状态，只不过跑的是无用指令，期望在执行无用指令时，锁能被释放出来

**解决思路：**根据以往自旋等待时能否获取到锁，来动态调整自旋的时间（循环尝试数量）

**自适应自旋：**如果在上一次自旋时获取到锁，则此次自旋时间稍微变长一点；如果在上一次自旋结束还没有获得锁，此次自旋时间稍微短一点

- 公平性

处于阻塞状态的线程无法立刻竞争被释放的锁；而处于自旋状态的线程含有可能先获取到锁

内建锁无法实现公平性，而lock体系可以实现公平锁

### Java对象头

monitor是Java对象头的标记

JDK1.6之后对内建锁做了优化（新增偏向、轻量级锁）

锁共有四种状态：

>1.无锁状态-0--01
>
>2.偏向锁-1--01
>
>3.轻量级锁--00
>
>4.重量级锁--10

由于无锁状态和偏向锁的标记位都是01，那么为了区分两种锁，在对象头标记中又设置了一个标记位，该标志位用于区分无锁状态和偏向锁状态

这四种状态随着竞争情况逐渐升级，**锁可以升级不能降级**，为了提高获得锁与释放锁的效率

- 偏向锁

最乐观的锁，从始至终只有一个线程请求一把锁，没有自旋状态

**偏向锁获取：**

当**一个线程**访问同步代码块并获取锁时，会在对象头和栈桢中的锁记录中记录储存偏向锁的线程ID，以后该线程再次进入同步代码块时，不再需要CAS来加锁和解锁，只需简单测试一下对象头的mark word中偏向锁线程ID是否是当前线程ID，如果成功，表示线程已经获取到锁直接进入代码块运行



如果测试失败，检查当前偏向锁字段是否为0，如果为0，采用CAS操作将偏向锁字段设置为1，并且更新自己的线程ID到mark word字段中



如果为1，表示此时偏向锁已经被别的线程获取，则此线程需要不断尝试使用CAS获取偏向锁；或者将偏向锁撤销，升级为轻量级锁，升级为轻量级锁的概率比较高

加锁过程如图：

<div align="center">
	<img src="/images/posts/CAS乐观锁/偏向锁.png" height="673" width="388">  
</div>
**偏向锁的撤销：**

偏向锁使用一种等到竞争出现才释放锁的机制，当有其他进程尝试竞争偏向锁时，持有偏向锁的进程才会释放偏向锁

<font color = red>注意：</font>偏向锁的撤销开销比较大，需要等待线程进入全局安全点safepoint（当前线程在CPU上没有执行任何有用字节码）

偏向锁在JDK6之后默认开启，但是他在应用程序启动几秒后才激活。

-XX：BiasedLockingStartupDelay=0，将延迟关闭，JVM一启动就激活偏向锁

-XX：-UseBiasedLocking=false，关闭偏向锁，程序默认进入轻量级锁

- 轻量级锁

**概念：**

**多个线程**在不同时间段，请求同一把锁，也就是基本不存在锁竞争。针对此种状况，JVM采用轻量级锁来避免线程的堵塞以及唤醒

**加锁过程：**

线程在执行同步代码块之前，JVM先在当前线程的栈桢中创建**用于存储锁记录**的空间，并将对象头的mark word字段直接复制到此空间中，然后线程尝试使用CAS将对象头的mark word替换为指向锁记录的指针（指向当前线程），如果成功表示获取到轻量级锁。如果失败，表示其他线程竞争轻量级锁，当前线程便使用自旋来不断尝试 

**释放过程：**

解锁时，会使用CAS将复制的mark word替换回对象头，如果成功，表示没有竞争发生，正常解锁；如果失败，表示当前所存在竞争，进一步膨胀为重量级锁

<div align="center">
	<img src="/images/posts/CAS乐观锁/轻量级锁.png" height="547" width="730">  
</div>

- 重量级锁

重量级锁会阻塞、唤醒请求加锁的线程。针对的是多个线程同一时刻竞争同一把锁的情况，JVM采用自适应自旋，来避免线程在面对非常小的同步块时，仍会被阻塞以及唤醒。

轻量级锁采用CAS操作，将锁对象的标记字段替换为指向线程的指针，存储着锁对象原本的标记字段。针对的是多个线程在不同时间段申请同一把锁的情况

偏向锁只会在第一次请求时采用CAS操作，在锁对象的mark word字段中记录下当前线程ID，此后运行中持有偏向锁的线程不再有加锁过程。针对的是锁仅会被同一线程持有

欢迎交流~

转载请注明原地址：[Lucky-pxx的博客](http://www.bingoxin.top) » [点击阅读原文](http://www.bingoxin.top/2018/11/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/),谢谢！