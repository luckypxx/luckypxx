---
layout: post
title: 自定义类型 
date: 2018-03-05 
tag: C语言
---

### 为什么存在内存对齐

>1.**平台原因：**不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常

>2.**性能原因：**数据结构(尤其是栈)应该尽可能地在自然边界上对齐
>-->若访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要访问一次就可以拿到数据

### 结构体内存对齐规则

Linux中，默认对齐数是4

Windows下的vs，默认对齐数是8

>1.第一个成员在与结构体变量偏移量为0的地址处
> 
>2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处--->对齐数=编译器默认的一个对齐数与该成员大小的较小值
>
>3.结构体总大小为最大对齐数的整数倍
>
>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍

可以说，内存对齐是用时间来弥补空间

### 结构体传参

结构体传参时，考虑变量可能过大，不要传结构体变量，要传结构体指针

### 位段

位段的声明和结构是类似的，有两个不同点：

>1.位段的成员必须是int、unsigned int 或 signed int
>
>2.位段的成员后边有一个冒号和一个数字

位段成员后面的数字表示bit位，位段可以节省空间

**开辟空间方式**

由于位段里变量为int类型，因此在开辟空间时，一次开辟4个字节的空间，即32个bit位。

需要注意的是：**位段是不可以跨平台的、位段不存在对齐**

### 枚举(enum)

枚举，即一一列举

枚举列举的是枚举常量，第一个常量为0，之后的常量大小依次+1

**枚举的优点**

- 增加代码的可读性和可维护性
- 和#define定义的标识符比较，枚举有类型检查，更加严谨
- 防止命名污染
- 便于调试
- 使用方便，一次可以定义多个常量

### 联合(共用体)

在共用体中定义的变量共用一块内存

**空间计算**

- 联合的大小至少是最大成员的大小
- 当最大成员不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍

### 大小端

小端：低字节放低地址处，高字节放高地址处

大端：低字节放高地址，高字节放低地址

### IP地址

IP地址是由点分十进制的方式处理的

IP地址实际是整型的十进制数字，将十进制数字的每个字节转化成转化成十进制，再用.连接，就是IP地址

代码实现：
    #include <stdio.h>
    #include <Windows.h>
    
    union un
    {
    	unsigned int num;
    	struct 
    	{
    		unsigned char a;
    		unsigned char b;
    		unsigned char c;
    		unsigned char d;
    	};
    };
    
    int main()
    {
    	union un myip;
    	myip.num = 716872929;
    	printf("%d.%d.%d.%d", myip.d, myip.c, myip.b, myip.a);
    	system("pause");
    	return 0;
    }

欢迎交流~~

转载请注明原地址：[Lucky-pxx的博客](http://www.bingoxin.top) » [点击阅读原文](http://www.bingoxin.top/2018/04/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/),谢谢！





